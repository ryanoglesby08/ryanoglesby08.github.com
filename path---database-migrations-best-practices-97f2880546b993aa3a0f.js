webpackJsonp([0xc013edf9cf48],{439:function(e,t){e.exports={data:{site:{siteMetadata:{title:"Ryan Oglesby"}},markdownRemark:{id:"/Users/ryanoglesby/Projects/blog/src/src/pages/database-migrations-best-practices/index.md absPath of file >>> MarkdownRemark",html:'<p>Only once have I worked on a project that did not interact directly with a relational database.\n(Awww, those were the days) In every other case, I used database migrations to apply small changes\nto a database over time. Using migrations provides an incremental path towards building the current\nstate of a database. In my opinion it’s the only way to do it.</p>\n<p>Database migrations are nothing new, and over the years I have come to follow a few best practices:</p>\n<!-- more -->\n<h2>1 Migration - 1 Change - 1 Commit</h2>\n<p><strong>Each migration should execute a single unit of work on the database.</strong> This comes from the Agile\nsoftware development principle of introducing\n<a href="https://en.wikipedia.org/wiki/Agile_software_development#Iterative.2C_incremental_and_evolutionary">small, incremental changes</a>.\nSmall migrations are easier to read and understand.</p>\n<p>For example, if I need to create a customers table and accounts table, I would create one migration\nto create the customers table and a second migration to create the accounts table. Two migrations.\nTwo commits.</p>\n<p>By keeping each migration contained in its own commit, it is easy for automated build systems to\napply them 1-by-1 in later environments. And if a migration turns out to be malformed, you make it\neasy to revert just that change if necessary.</p>\n<p><em>I always try to commit a migration with no code changes attached.</em> This isolation ensures that the\nmigration is fully compatible with the application code both before and after it. Your Database\nAdministrators will also thank you for making it easier to notice the migration when its all by\nitself.</p>\n<h2>Never modify a previously committed migration</h2>\n<p>(This is the one that seems to be unintuitive for less experienced developers.)</p>\n<p>Once a commit has left my local machine, it is effectively locked! If I notice afterwards that there\nis a typo in a column name or some other mistake, I create another migration that fixes it rather\nthan modifying the bad one.</p>\n<p>Why? Imagine this interaction between 2 developers, Patrick and Molly:</p>\n<table>\n  <thead>\n    <tr>\n      <th>Patrick</th>\n      <th>Molly</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>1. Patrick commits migration #8, which creates a table with a column "product_typ" (misspelled it, oops)</td>\n      <td></td>\n    </tr>\n    <tr>\n      <td></td>\n      <td>2. Molly pulls new code and applies migrations, which gives her the new table with the misspelled column name</td>\n    </tr>\n    <tr>\n      <td>3. Patrick realizes his mistake, so he rolls back migration #8 locally, dropping the table. He then modifies the migration to fix the typo, then applies migration #8 again.</td>\n      <td></td>\n    </tr>\n    <tr>\n      <td>4. Patrick pushes his changes.</td>\n      <td></td>\n    </tr>\n    <tr>\n      <td></td>\n      <td>5. Molly pulls new code and applies migrations again. But this time no change is made to her database because she already applied migration #8 and no new migrations were added. She is stuck with the typo. :(</td>\n    </tr>\n    <tr>\n      <td colspan="2" class="center">6. Patrick\'s and Molly\'s database schemas are now out of sync.</td>\n    </tr>\n  </tbody>\n</table>\n<p>The only way Molly can fix her database now is to drop it and start over. Depending on the migration\nand what was changed, she may not be able to rollback for a quick fix. Want a scarier scenario? What\nif Molly was actually the production database… Oops indeed.</p>\n<p>Save yourself the pain. Just don’t do it.</p>\n<h2>Avoid using your application code (such as models) in migrations</h2>\n<p>Some migration tools allow you to use application code in your migration files, especially if you\nare using the ActiveRecord pattern\n<a href="http://guides.rubyonrails.org/v3.2.8/migrations.html#using-models-in-your-migrations">(I’m looking at you Rails)</a>.\nThe use case for this could be an easy way to do some data manipulation, or inserting seed data.</p>\n<p>I avoid doing this because you cannot guarantee that your code will keep the same API forever. Even\nthe first migration could be run at any point in the future (say a new dev joins and runs them all\nfor the first time), you can’t assume those same methods could be called. (And I don’t change\npreviously run migrations)</p>\n<p>P.S. Rails 4 no longer even mentions this as an option. The link above from Rails Guides actually\nwarns against this practice too. :)</p>\n<h2>Keep migrations abstract</h2>\n<p>Try not to use database-specific operations. This couples you to that database technology. Most\nmigration tools/frameworks attempt to abstract the database away for you, so by using\ndatabase-specific concepts or operations, you break that abstraction layer.</p>\n<p>However, this rule is often broken since each database speaks its own version of SQL.</p>\n<h2>Think about the data</h2>\n<p>I often see developers overlooking the data stored in their databases. Migrations don’t just effect\nthe schema, they also effect the stored data - a thats the important part! This happens a lot\nbecause our local development databases may not have very production-like data.</p>\n<p>Example: Consider a migration that applies a not null constraint to a column.</p>\n<table class="blog-table even">\n  <thead>\n    <tr>\n      <th>Local DB</th>\n      <th>Production DB</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>\nemployees\n<pre>\nid | name       | phone_number\n---------------------------\n1 | foo         | 5555555555\n2 | l33t haxor  | 1234567890\n</pre>\n      </td>\n      <td>\nemployees\n<pre>\nid | name   | phone_number\n---------------------------\n1 | Patrick | 5554567890\n2 | Molly   | null\n</pre>\n      </td>\n    </tr>\n  </tbody>\n</table>\n<div class="gatsby-highlight">\n      <pre class="language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> employees <span class="token keyword">MODIFY</span> phone_number <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span>\n</code></pre>\n      </div>\n<p>This migration would be fine in development, but that migration would fail in prod. A better\nmigration would actually be 3 steps:</p>\n<ol>\n<li>Insert a value into every row where <code>phone_number</code> is currently null</li>\n<li>Add a default value for future inserts (if applicable)</li>\n<li>Introduce the not null constraint.</li>\n</ol>\n<p>Consider changing a column’s data type from a floating point precision to an integer. Maybe you are\nconverting your money column to be stored as cents so you can avoid floating point mathematical\nerrors. What would happen to the precision when the migration is applied? Would the database\ntruncate it? Round it? Something else?</p>\n<p>A more pragmatic approach may actually require many steps: introduce another column\n<code>amount_in_cents</code>; move all the current data to the new column and perform the format change; drop\nthe <code>amount</code> column; finally, rename the <code>amount_in_cents</code> column to <code>amount</code>.</p>\n<p>These are only two scenarios I’ve seen lately, but there are many more.</p>\n<h2>Moar</h2>\n<p>Check out <a href="http://databaserefactoring.com/">Database Refactoring</a> for a lot of good database\nrefactoring patterns.</p>',frontmatter:{title:"Database Migrations Best Practices",date:"August 15, 2015"}}},pathContext:{slug:"/database-migrations-best-practices/",previous:{fields:{slug:"/hackathons-for-the-enterprise/"},frontmatter:{title:"Hackathons for the Enterprise"}},next:{fields:{slug:"/youre-a-champion/"},frontmatter:{title:"You're a Champion"}}}}}});
//# sourceMappingURL=path---database-migrations-best-practices-97f2880546b993aa3a0f.js.map