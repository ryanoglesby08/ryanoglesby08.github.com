webpackJsonp([0xdc9a04a28cb9],{513:function(e,t){e.exports={data:{site:{siteMetadata:{title:"Ryan Oglesby"}},markdownRemark:{id:"/Users/ryanoglesby/projects/ryanoglesby08.github.com/src/pages/yagni-aint-a-design-principle/index.md absPath of file >>> MarkdownRemark",html:'<p><a href="http://c2.com/cgi/wiki?YouArentGonnaNeedIt">You Ain’t Gonna Need It</a> is an XP practice that\nencourages developers to focus on the requirements at hand right now. It warns against the tendency\nto over-engineer by developing features based on what you <strong>think</strong> you will need later. Easy in\ntheory. Hard in practice.</p>\n<h2>YAGNI Blinders</h2>\n<p>I’ve noticed that developers, especially those just starting out, tend to apply YAGNI\nnarrow-sightedly. I often see it being strictly adhered to at face-value only, by developers always\nchoosing to do what seems to be the most obvious and straightforward thing at the time, without\nputting any thought into the design implications of their choices. When suggesting other options\nthat seem to be less simple on the surface, they YAGNI argument gets used. “Oh, that’s YAGNI.”</p>\n<!-- more -->\n<p>YAGNI encourages simplicity. But many developers read simple as easy, which can lead to design\nproblems with their code that easily have been avoided. An easy solution doesn’t require any thought\nor skill. A simple solution involves elegance, is purposeful, and is built with extensibility and\nevolvability in mind. <em>(Rich Hickey, the creator of Clojure, gave a wonderful talk along these same\nlines in 2011. <a href="http://www.infoq.com/presentations/Simple-Made-Easy">Simple Made Easy</a>)</em></p>\n<p>As an example of YAGNI Blinders, take internationalization (i18n) of a web-app. Usually, the first\nrequirement is to support only a single language, with support for other languages pretty far down\nthe line. A classic YAGNI solution here: hard coding everything in the HTML files. Done. (I’ll come\nback to this soon….)</p>\n<h2>See the Light!</h2>\n<p>The YAGNI argument breaks down because it does not take critical design characteristics such as\nreadability, flexibility, and loose coupling into account. A purely YAGNI-based solution does not\nnecessarily imply those things. By sticking to a YAGNI-only solution, you make it harder to quickly\nmove forward later, because extensive refactoring or rewriting would be needed first. By considering\nsimplicity along with many other design principles, you will end up with better factored code.</p>\n<p>The most obvious choice is not always the right one. YAGNI does not mean to plow headfirst into the\nfirst solution you think of. Good design trumps. But figuring out how to satisfy the requirements at\nhand, while building a simple, flexible solution without gold-plating, over-engineering, or solving\nfor unknown future requirements is hard! Good. Glad our job isn’t boring. :)</p>\n<p>Back to i18n, instead of hard coding all the strings in the HTML, we can introduce a simple lookup\nmechanism. We store all our strings in a JSON file, and create a simple module that loads that file\ninto a map structure, so that strings can be looked up by a key.</p>\n<p>Yes, this is not the absolute easiest solution. However, it is simple, and a better design. We have\nbetter separation of concerns. We have pushed configuration (the strings) out of code, allowing them\nto change independently as they may change at a different rate than the application code. We could\nextend the lookup mechanism without changing the strings or keys. Event If we never get a\nrequirement to add another language, this is still a better design, and we did not have to build a\ncomplex architecture involving locales, multiple languages, unicode character support, or any of the\nother myriad of problems that come with i18n. Not easy, but simple.</p>\n<blockquote>\n<p>You always need good design. If you find yourself with a pair of YAGNI blinders on, ignoring\ndesign and code quality for purely YAGNI arguments, take a step back and remember that YAGNI ain’t\na design principle.</p>\n</blockquote>',frontmatter:{title:"YAGNI a'int a Design Principle",date:"February 12, 2016"}}},pathContext:{slug:"/yagni-aint-a-design-principle/",previous:{fields:{slug:"/youre-a-champion/"},frontmatter:{title:"You're a Champion"}},next:{fields:{slug:"/how-your-mother-can-help-you-build-cleaner-unit-tests/part-i/"},frontmatter:{title:"How your 'Mother' can help you 'Build' cleaner unit tests - Part I"}}}}}});
//# sourceMappingURL=path---yagni-aint-a-design-principle-d1b6d5b6b747b7a9367e.js.map