<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: docker | Ryan Oglesby]]></title>
  <link href="http://ryanogles.by/categories/docker/atom.xml" rel="self"/>
  <link href="http://ryanogles.by/"/>
  <updated>2016-10-16T16:23:54+01:00</updated>
  <id>http://ryanogles.by/</id>
  <author>
    <name><![CDATA[Ryan Oglesby]]></name>
    <email><![CDATA[{"address"=>"ryan.oglesby08@gmail.com"}]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Homogeneous Pipelines with Docker]]></title>
    <link href="http://ryanogles.by/docker/2016/09/26/homogeneous-pipelines-with-docker.html"/>
    <updated>2016-09-26T15:55:17+01:00</updated>
    <id>http://ryanogles.by/docker/2016/09/26/homogeneous-pipelines-with-docker</id>
    <content type="html"><![CDATA[[Continuous Integration Build Pipelines](http://martinfowler.com/articles/continuousIntegration.html) are a dirty, nasty place. What usually starts out as a couple of simple tasks or bash scripts inevitably ends up as a heap of scripts, Gradle/Rake/Maven/(insert build tool here) tasks, and manually configured jobs held together with a thin layer of Elmer's glue and Scotch tape.

Why? Partly because modern applications are complex; even simple stacks use multiple languages and tools. And partly because developers are lazy, and sometimes hesitant to "mess with the pipeline." I don't often see the amount of rigor in cleanliness applied to them as to other parts of the codebase, leading to unnecessarily complex and unfortunately tangled build pipelines.

So, my current team attacked this head-on using a great piece of technology: [Docker](https://www.docker.com)! Using Docker as our sole interface to running things in our build pipeline, we sped it up, simplified it, and lived happily ever after.

*To give credit where credit is due, the implementation of this pattern was spearheaded by my colleague [Amber Houle](https://twitter.com/amber_ht).*

<!-- more -->

Anatomy of a Pipeline
--------------------
This is pretty much what our build pipeline looked like in the time before Docker. Notice the amount of variation in what is being invoked in each step! (All these steps could be wrapped up in bash scripts, but I've unravelled them here.)

*"client" is a JS front-end application. "api" is a Java-based API.*

<figure class='code-highlight-figure'><figcaption class='code-highlight-caption'><span class='code-highlight-caption-title'>pipeline.yml</span></figcaption><div class='code-highlight'><pre class='code-highlight-pre'><div data-line='1' class='code-highlight-row numbered'><div class='code-highlight-line'><span class="s">build client</span><span class="pi">:</span>
</div></div><div data-line='2' class='code-highlight-row numbered'><div class='code-highlight-line'>  <span class="pi">-</span> <span class="s">npm install</span>       <span class="c1"># Install JS dependencies</span>
</div></div><div data-line='3' class='code-highlight-row numbered'><div class='code-highlight-line'>  <span class="pi">-</span> <span class="s">npm run webpack</span>   <span class="c1"># Compile to JS</span>
</div></div><div data-line='4' class='code-highlight-row numbered'><div class='code-highlight-line'> </div></div><div data-line='5' class='code-highlight-row numbered'><div class='code-highlight-line'><span class="s">build api</span><span class="pi">:</span>
</div></div><div data-line='6' class='code-highlight-row numbered'><div class='code-highlight-line'>  <span class="pi">-</span> <span class="s">gradle build</span>      <span class="c1"># Compile Java</span>
</div></div><div data-line='7' class='code-highlight-row numbered'><div class='code-highlight-line'> </div></div><div data-line='8' class='code-highlight-row numbered'><div class='code-highlight-line'><span class="s">test client</span><span class="pi">:</span>
</div></div><div data-line='9' class='code-highlight-row numbered'><div class='code-highlight-line'>  <span class="pi">-</span> <span class="s">npm install</span>                   <span class="c1"># Install JS dependencies..... again</span>
</div></div><div data-line='10' class='code-highlight-row numbered'><div class='code-highlight-line'>  <span class="pi">-</span> <span class="s">npm test</span>                      <span class="c1"># Run JS tests</span>
</div></div><div data-line='11' class='code-highlight-row numbered'><div class='code-highlight-line'> </div></div><div data-line='12' class='code-highlight-row numbered'><div class='code-highlight-line'><span class="s">test api</span><span class="pi">:</span>
</div></div><div data-line='13' class='code-highlight-row numbered'><div class='code-highlight-line'>  <span class="pi">-</span> <span class="s">systemctl start postgresql.service</span>  <span class="c1"># Start up Postgres</span>
</div></div><div data-line='14' class='code-highlight-row numbered'><div class='code-highlight-line'>  <span class="pi">-</span> <span class="s">flyway migrate</span>                      <span class="c1"># Migrate the database using Flyway</span>
</div></div><div data-line='15' class='code-highlight-row numbered'><div class='code-highlight-line'>  <span class="pi">-</span> <span class="s">gradle test</span>                         <span class="c1"># Run Java tests (unit and integration)</span>
</div></div><div data-line='16' class='code-highlight-row numbered'><div class='code-highlight-line'>  <span class="pi">-</span> <span class="s">systemctl stop postgresql.service</span>   <span class="c1"># Stop Postgres</span>
</div></div><div data-line='17' class='code-highlight-row numbered'><div class='code-highlight-line'> </div></div><div data-line='18' class='code-highlight-row numbered'><div class='code-highlight-line'><span class="s">package client</span><span class="pi">:</span>
</div></div><div data-line='19' class='code-highlight-row numbered'><div class='code-highlight-line'>  <span class="pi">-</span> <span class="s">npm install</span>                      <span class="c1"># Install JS dependencies once again :(</span>
</div></div><div data-line='20' class='code-highlight-row numbered'><div class='code-highlight-line'>  <span class="pi">-</span> <span class="s">npm run package</span>                  <span class="c1"># Package up the JS into a .zip or .tar</span>
</div></div><div data-line='21' class='code-highlight-row numbered'><div class='code-highlight-line'>  <span class="pi">-</span> <span class="s">&lt;push JS code to artifact repository&gt;</span>
</div></div><div data-line='22' class='code-highlight-row numbered'><div class='code-highlight-line'> </div></div><div data-line='23' class='code-highlight-row numbered'><div class='code-highlight-line'><span class="s">package api</span><span class="pi">:</span>
</div></div><div data-line='24' class='code-highlight-row numbered'><div class='code-highlight-line'>  <span class="pi">-</span> <span class="s">gradle package</span>                            <span class="c1"># Create an executable .jar</span>
</div></div><div data-line='25' class='code-highlight-row numbered'><div class='code-highlight-line'>  <span class="pi">-</span> <span class="s">&lt;push Java code to artifact repository&gt;</span>
</div></div><div data-line='26' class='code-highlight-row numbered'><div class='code-highlight-line'> </div></div><div data-line='27' class='code-highlight-row numbered'><div class='code-highlight-line'><span class="s">deploy to qa</span><span class="pi">:</span>
</div></div><div data-line='28' class='code-highlight-row numbered'><div class='code-highlight-line'>  <span class="pi">-</span> <span class="s">&lt;pull code from artifact repo and deploy&gt;</span></div></div></pre></div></figure>


Let's first examine a build pipeline that you might find using any of the modern open-source distributed build and deploy tools such as [Jenkins](https://jenkins.io/), [Go.cd](https://www.go.cd/), or [TravisCI](https://travis-ci.com/). It's broken down into a series of stages or jobs, which could be run sequentially or in parallel. Because these tools usually run as a [master/agent architecture](https://jenkins.io/doc/book/architecting-for-scale/), the server will delegate the actual work of each stage to an available build agent.

### Pipeline complexities
While this architecture is scalable and flexible, it creates complexities that **you** have to manage. Since each stage in your pipeline has a different job to do, all your agents must be configured to perform all needed actions. Some stages need a JavaScript runtime, some need Java, while others need a Postgres database. Traditionally, this calls for provisioning your agents with all the appropriate software ahead of time. And herein lies a dilemma. Manually provisioning might work fine if you only have 1 or 2 agents, but that quickly becomes tedious as the number of dependencies you have increases or the number of agents you need increases. Automated provisioning using Chef or Puppet is an option, but this creates one more piece of code to build, manage, test, and debug.

As each agent picks up a stage to run, it's going to need some input, which is often just a copy of your source code at a specific revision. Because any agent could be picking up any job at any time, the sequence is usually 1) start with a clean workspace 2) checkout the code 3) install dependencies 4) do stuff. All these steps take time, especially installing dependencies. (There are 3 `npm install` commands in the pipeline shown above)


Docker as the Pipeline Interface
----------------------
> Docker containers wrap a piece of software in a complete filesystem that contains everything needed to run: code, runtime, system tools, system libraries â€“ anything that can be installed on a server. <br/> <https://www.docker.com/what-docker>

What if we extend this statement to say that containers contain everything needed to run.... **and build and test**? Instead of provisioning build agents with all the individual pieces of software and dependencies that our pipeline needs, let's provision them with only the Docker Engine. Now, the sequence of steps for any stage becomes 1) Pull down a Docker image 2) Execute `docker run` <https://docs.docker.com/engine/reference/run/>.

To pull this off, we first need to create some Docker images with **everything our application needs to build and test itself**, which we specify with a [Dockerfile](https://docs.docker.com/engine/reference/builder/).

<figure class='code-highlight-figure'><figcaption class='code-highlight-caption'><span class='code-highlight-caption-title'>Dockerfile for Java API</span></figcaption><div class='code-highlight'><pre class='code-highlight-pre'><div data-line='1' class='code-highlight-row numbered'><div class='code-highlight-line'>FROM java:8
</div></div><div data-line='2' class='code-highlight-row numbered'><div class='code-highlight-line'> </div></div><div data-line='3' class='code-highlight-row numbered'><div class='code-highlight-line'>COPY build.gradle ./
</div></div><div data-line='4' class='code-highlight-row numbered'><div class='code-highlight-line'>COPY src ./src/
</div></div><div data-line='5' class='code-highlight-row numbered'><div class='code-highlight-line'> </div></div><div data-line='6' class='code-highlight-row numbered'><div class='code-highlight-line'>RUN gradle jar
</div></div><div data-line='7' class='code-highlight-row numbered'><div class='code-highlight-line'> </div></div><div data-line='8' class='code-highlight-row numbered'><div class='code-highlight-line'>ENTRYPOINT ["gradle"]</div></div></pre></div></figure>


<figure class='code-highlight-figure'><figcaption class='code-highlight-caption'><span class='code-highlight-caption-title'>Dockerfile for database migrations</span></figcaption><div class='code-highlight'><pre class='code-highlight-pre'><div data-line='1' class='code-highlight-row numbered'><div class='code-highlight-line'>FROM shouldbee/flyway
</div></div><div data-line='2' class='code-highlight-row numbered'><div class='code-highlight-line'> </div></div><div data-line='3' class='code-highlight-row numbered'><div class='code-highlight-line'>COPY ./src/main/resources/db/migration/*.sql ./sql/
</div></div><div data-line='4' class='code-highlight-row numbered'><div class='code-highlight-line'> </div></div><div data-line='5' class='code-highlight-row numbered'><div class='code-highlight-line'>ENTRYPOINT ["flyway"]</div></div></pre></div></figure>


<figure class='code-highlight-figure'><figcaption class='code-highlight-caption'><span class='code-highlight-caption-title'>Dockerfile for JS client</span></figcaption><div class='code-highlight'><pre class='code-highlight-pre'><div data-line='1' class='code-highlight-row numbered'><div class='code-highlight-line'>FROM node:6.4.0
</div></div><div data-line='2' class='code-highlight-row numbered'><div class='code-highlight-line'> </div></div><div data-line='3' class='code-highlight-row numbered'><div class='code-highlight-line'>COPY package.json ./
</div></div><div data-line='4' class='code-highlight-row numbered'><div class='code-highlight-line'>RUN npm install
</div></div><div data-line='5' class='code-highlight-row numbered'><div class='code-highlight-line'>COPY src ./src/
</div></div><div data-line='6' class='code-highlight-row numbered'><div class='code-highlight-line'>RUN npm run webpack
</div></div><div data-line='7' class='code-highlight-row numbered'><div class='code-highlight-line'> </div></div><div data-line='8' class='code-highlight-row numbered'><div class='code-highlight-line'>ENTRYPOINT [ "npm", "run" ]</div></div></pre></div></figure>


And this is pretty much what our pipeline evolved into after transitioning to Docker...
<figure class='code-highlight-figure'><figcaption class='code-highlight-caption'><span class='code-highlight-caption-title'>pipeline.yml</span></figcaption><div class='code-highlight'><pre class='code-highlight-pre'><div data-line='1' class='code-highlight-row numbered'><div class='code-highlight-line'><span class="s">build client</span><span class="pi">:</span>
</div></div><div data-line='2' class='code-highlight-row numbered'><div class='code-highlight-line'>  <span class="pi">-</span> <span class="s">docker build -t client:$&#x7b;PIPELINE_ID&#x7d; ./client</span>  <span class="c1"># Build Docker image</span>
</div></div><div data-line='3' class='code-highlight-row numbered'><div class='code-highlight-line'>  <span class="pi">-</span> <span class="s">docker push client:$&#x7b;PIPELINE_ID&#x7d;</span>               <span class="c1"># Push it to the container registry</span>
</div></div><div data-line='4' class='code-highlight-row numbered'><div class='code-highlight-line'> </div></div><div data-line='5' class='code-highlight-row numbered'><div class='code-highlight-line'><span class="s">build api</span><span class="pi">:</span>
</div></div><div data-line='6' class='code-highlight-row numbered'><div class='code-highlight-line'>  <span class="pi">-</span> <span class="s">docker build -t api:$&#x7b;PIPELINE_ID&#x7d; ./api</span>
</div></div><div data-line='7' class='code-highlight-row numbered'><div class='code-highlight-line'>  <span class="pi">-</span> <span class="s">docker build -t migrations:$&#x7b;PIPELINE_ID&#x7d; ./api</span>
</div></div><div data-line='8' class='code-highlight-row numbered'><div class='code-highlight-line'> </div></div><div data-line='9' class='code-highlight-row numbered'><div class='code-highlight-line'>  <span class="pi">-</span> <span class="s">docker push api:$&#x7b;PIPELINE_ID&#x7d;</span>
</div></div><div data-line='10' class='code-highlight-row numbered'><div class='code-highlight-line'>  <span class="pi">-</span> <span class="s">docker push migrations:$&#x7b;PIPELINE_ID&#x7d;</span>
</div></div><div data-line='11' class='code-highlight-row numbered'><div class='code-highlight-line'> </div></div><div data-line='12' class='code-highlight-row numbered'><div class='code-highlight-line'><span class="s">test client</span><span class="pi">:</span>
</div></div><div data-line='13' class='code-highlight-row numbered'><div class='code-highlight-line'>  <span class="pi">-</span> <span class="s">docker pull client:$&#x7b;PIPELINE_ID&#x7d;</span>
</div></div><div data-line='14' class='code-highlight-row numbered'><div class='code-highlight-line'>  <span class="pi">-</span> <span class="s">docker run client:$&#x7b;PIPELINE_ID&#x7d; test</span>   <span class="c1"># Run `npm run test` inside of the client container</span>
</div></div><div data-line='15' class='code-highlight-row numbered'><div class='code-highlight-line'> </div></div><div data-line='16' class='code-highlight-row numbered'><div class='code-highlight-line'><span class="s">test api</span><span class="pi">:</span>
</div></div><div data-line='17' class='code-highlight-row numbered'><div class='code-highlight-line'>  <span class="pi">-</span> <span class="s">docker pull api:$&#x7b;PIPELINE_ID&#x7d;</span>
</div></div><div data-line='18' class='code-highlight-row numbered'><div class='code-highlight-line'>  <span class="pi">-</span> <span class="s">docker pull migrations:$&#x7b;PIPELINE_ID&#x7d;</span>
</div></div><div data-line='19' class='code-highlight-row numbered'><div class='code-highlight-line'> </div></div><div data-line='20' class='code-highlight-row numbered'><div class='code-highlight-line'>  <span class="pi">-</span> <span class="s">docker run migrations:$&#x7b;PIPELINE_ID&#x7d; migrate</span>  <span class="c1"># Run `flyway migrate` inside of the migrations container</span>
</div></div><div data-line='21' class='code-highlight-row numbered'><div class='code-highlight-line'>  <span class="pi">-</span> <span class="s">docker run api:$&#x7b;PIPELINE_ID&#x7d; test</span>            <span class="c1"># Run `gradle test` inside of the api container</span></div></div></pre></div></figure>


### Complexities simplified
Overall, this had a number of positive effects on our build pipeline. First, **speed**: the time from pipeline start to ready to deploy to a QA environment dropped from ~12 minutes to ~4 minutes! This was largely due to no longer checking out the entire code base, installing dependencies, and re-compiling in each step of the pipeline. Second, **simplicity.** Configuring new build agents is now easy, as they only need Docker Engine. The single command interface is also cognitively simple. Each call to `docker run [COMMAND]` in the pipeline acts as a proxy to the task runner already in use in the codebase (e.g `gradle [COMMAND]` or `npm run [COMMAND]`), making it work just like local development without Docker.

The main possible issue I see with this is that the Docker container has a large surface area, which kind of goes against the advice from Docker to keep images as slim and trim as possible. I normally would not include all my test code into the deployable artifact that will eventually end up on my production server. Instead we have copied **all** the source and test code into the image. This could introduce dependency issues, such as security holes that may exist in libraries pulled in by test code. I have not observed this in practice though.

You will also notice that we push the Docker image to the registry right away. This ensures that the artifact that passes down the pipeline is exactly the same all the way through build, test, and deploy. But, it also means we are creating an artifact for un-verified code. What if the tests fail for a certain commit, but we have already created and pushed the Docker image? Do we leave it in the registry? Remove it? So far, we have just left them there, so not sure how this will play out in the long term.

Overall, this pattern has worked well for the team! Would love to hear your opinions and experiences with Docker in a build pipeline.
]]></content>
  </entry>
  
</feed>
