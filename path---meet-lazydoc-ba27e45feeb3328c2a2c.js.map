{"version":3,"sources":["webpack:///path---meet-lazydoc-ba27e45feeb3328c2a2c.js","webpack:///./.cache/json/meet-lazydoc.json"],"names":["webpackJsonp","500","module","exports","data","site","siteMetadata","title","markdownRemark","id","html","frontmatter","date","pathContext","slug","previous","fields","next"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,MAAQC,cAAgBC,MAAA,iBAAwBC,gBAAmBC,GAAA,0GAAAC,KAAA,0sPAAAC,aAA2hQJ,MAAA,eAAAK,KAAA,uBAAoDC,aAAgBC,KAAA,iBAAAC,UAAoCC,QAAUF,KAAA,yBAA+BH,aAAgBJ,MAAA,wBAA+BU,MAASD,QAAUF,KAAA,yCAA+CH,aAAgBJ,MAAA","file":"path---meet-lazydoc-ba27e45feeb3328c2a2c.js","sourcesContent":["webpackJsonp([74163788938612],{\n\n/***/ 500:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Ryan Oglesby\"}},\"markdownRemark\":{\"id\":\"/Users/ryanoglesby/Projects/blog/src/src/pages/meet-lazydoc/index.md absPath of file >>> MarkdownRemark\",\"html\":\"<p>I’ve been pretty heads down in a <a href=\\\"http://www.thoughtworks.com\\\">ThoughtWorks</a> project for the better\\npart of 2013 and have unfortunately neglected this blog. But 2014 is a new year and I want to get\\ninto a semi-regular cadence of posts.</p>\\n<p>So with that in mind…… another long overdue post! So say hello to\\n<a href=\\\"https://github.com/ryanoglesby08/lazy-doc\\\">LazyDoc</a>, a Ruby gem I have released. LazyDoc provides a\\nDSL for extracting deeply nested values from a JSON document.</p>\\n<h2>Working with APIs</h2>\\n<p>In many projects I work on these days, the application consumes a 3rd party or internal API. In\\nRuby, it’s tempting to just parse a JSON response from an API into a Hash and then pass that around\\nyour application.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-ruby\\\"><code class=\\\"language-ruby\\\"><span class=\\\"token keyword\\\">def</span> <span class=\\\"token function\\\">extract_user_from</span><span class=\\\"token punctuation\\\">(</span>json_body<span class=\\\"token punctuation\\\">)</span>\\n  <span class=\\\"token constant\\\">JSON</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">parse</span><span class=\\\"token punctuation\\\">(</span>json_body<span class=\\\"token punctuation\\\">)</span>\\n<span class=\\\"token keyword\\\">end</span></code></pre>\\n      </div>\\n<p>This “works”, but now your application is tightly coupled to the structure of the API response. The\\nfields your application needs are never defined, making it tough to know what you have available to\\nuse. Is the “name” field “first_name”, “firstName”, or just “name”?</p>\\n<p>Ok, easy enough solution for that. Objects to the rescue!</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-ruby\\\"><code class=\\\"language-ruby\\\"><span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">User</span>\\n  attr_reader <span class=\\\"token symbol\\\">:first_name</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token symbol\\\">:last_name</span>\\n\\n  <span class=\\\"token keyword\\\">def</span> <span class=\\\"token function\\\">initialize</span><span class=\\\"token punctuation\\\">(</span>first_name<span class=\\\"token punctuation\\\">,</span> last_name<span class=\\\"token punctuation\\\">)</span>\\n    <span class=\\\"token variable\\\">@first_name</span> <span class=\\\"token operator\\\">=</span> first_name\\n    <span class=\\\"token variable\\\">@last_name</span> <span class=\\\"token operator\\\">=</span> last_name\\n  <span class=\\\"token keyword\\\">end</span>\\n<span class=\\\"token keyword\\\">end</span>\\n\\n<span class=\\\"token punctuation\\\">.</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token punctuation\\\">.</span>\\n\\n<span class=\\\"token keyword\\\">def</span> <span class=\\\"token function\\\">extract_user_from</span><span class=\\\"token punctuation\\\">(</span>json_body<span class=\\\"token punctuation\\\">)</span>\\n  body <span class=\\\"token operator\\\">=</span> <span class=\\\"token constant\\\">JSON</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">parse</span><span class=\\\"token punctuation\\\">(</span>json_body<span class=\\\"token punctuation\\\">)</span>\\n  <span class=\\\"token constant\\\">User</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token keyword\\\">new</span><span class=\\\"token punctuation\\\">(</span>body<span class=\\\"token punctuation\\\">[</span><span class=\\\"token string\\\">'first_name'</span><span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">,</span> body<span class=\\\"token punctuation\\\">[</span><span class=\\\"token string\\\">'last_name'</span><span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">)</span>\\n<span class=\\\"token keyword\\\">end</span></code></pre>\\n      </div>\\n<p>Now we have separated the JSON response from our application domain. Sweet! Ok, done… Right? Not\\nquite. There are a few problems here.</p>\\n<ol>\\n<li>What about everything else in <code class=\\\"language-text\\\">json_body</code>? It is now lost. :(</li>\\n<li>What do you do when you need to extract more information from that JSON response? This code isn’t\\nvery flexible. Either you end up with a constructor that takes in too many arguments, or you end\\nup with too many setters on your <code class=\\\"language-text\\\">User</code> object.</li>\\n<li>Many times you want to massage your API response data a little bit before adding it to your\\nobject. These massaging operations end up going into random helper methods that end up being\\nduplicated all over your codebase.</li>\\n</ol>\\n<p>We can do better.</p>\\n<h2>Embedded Document Pattern</h2>\\n<p>The <strong>Embedded Document Pattern</strong> to the rescue! Defined by Martin Fowler\\n<a href=\\\"http://martinfowler.com/bliki/EmbeddedDocument.html\\\">here</a>. With this pattern, instead of parsing\\nthrough your documents when they are received and building object graphs, we cache the document and\\nonly parse through it when necessary. Because sometimes your document may be large compared to the\\nnumber of properties your application actually needs, you can save complexity and time.</p>\\n<p>The LazyDoc gem is a Ruby implementation of the Embedded Document Pattern. You maintain access to\\nthe entire JSON response, which makes it easy to add, update, or remove fields from your object as\\nyou need. You retain flexibility. Any massaging that needs to be done to the fields becomes easy to\\nmanage.</p>\\n<p>So now, with LazyDoc:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-ruby\\\"><code class=\\\"language-ruby\\\"><span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">User</span>\\n  include <span class=\\\"token constant\\\">LazyDoc</span><span class=\\\"token punctuation\\\">:</span><span class=\\\"token punctuation\\\">:</span><span class=\\\"token constant\\\">DSL</span>\\n\\n  access <span class=\\\"token symbol\\\">:first_name</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token symbol\\\">:last_name</span>\\n  access <span class=\\\"token symbol\\\">:address</span><span class=\\\"token punctuation\\\">,</span> default<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">'NONE PROVIDED'</span>\\n\\n  <span class=\\\"token keyword\\\">def</span> <span class=\\\"token function\\\">initialize</span><span class=\\\"token punctuation\\\">(</span>document<span class=\\\"token punctuation\\\">)</span>\\n    <span class=\\\"token function\\\">lazily_parse</span><span class=\\\"token punctuation\\\">(</span>document<span class=\\\"token punctuation\\\">)</span>\\n  <span class=\\\"token keyword\\\">end</span>\\n<span class=\\\"token keyword\\\">end</span>\\n\\n<span class=\\\"token punctuation\\\">.</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token punctuation\\\">.</span>\\n\\n<span class=\\\"token keyword\\\">def</span> <span class=\\\"token function\\\">extract_user_from</span><span class=\\\"token punctuation\\\">(</span>json_body<span class=\\\"token punctuation\\\">)</span>\\n  <span class=\\\"token constant\\\">User</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token keyword\\\">new</span><span class=\\\"token punctuation\\\">(</span>json_body<span class=\\\"token punctuation\\\">)</span>\\n<span class=\\\"token keyword\\\">end</span></code></pre>\\n      </div>\\n<h2>Lazy?</h2>\\n<p>So why is it called <em>Lazy</em>Doc? The lazy feature is one of the coolest parts of this gem. The\\ndeclarative method <code class=\\\"language-text\\\">access :first_name</code> merely defines a method that is able to fetch the\\n<code class=\\\"language-text\\\">first_name</code> property from the JSON body. Only upon calling the method will the property be\\nextracted and massaged according to any defined operations. Additionally, the returned value will be\\ncached, so any subsequent calls will only return the cached value.</p>\\n<p>Check the <a href=\\\"https://github.com/ryanoglesby08/lazy-doc\\\">README</a> for more information and examples.\\nAlso, the <a href=\\\"https://github.com/ryanoglesby08/lazy-doc/tree/v0.4.0/spec/acceptance\\\">acceptance specs</a>\\nhave full example usage.</p>\\n<p>Feel free to download and use in your next project! Feedback is welcome!</p>\",\"frontmatter\":{\"title\":\"Meet LazyDoc\",\"date\":\"December 25, 2013\"}}},\"pathContext\":{\"slug\":\"/meet-lazydoc/\",\"previous\":{\"fields\":{\"slug\":\"/fun-with-rails-i18n/\"},\"frontmatter\":{\"title\":\"Fun With Rails I18n\"}},\"next\":{\"fields\":{\"slug\":\"/goto-chicago-2014-experience-report/\"},\"frontmatter\":{\"title\":\"GOTO Chicago 2014 Experience Report\"}}}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---meet-lazydoc-ba27e45feeb3328c2a2c.js","module.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Ryan Oglesby\"}},\"markdownRemark\":{\"id\":\"/Users/ryanoglesby/Projects/blog/src/src/pages/meet-lazydoc/index.md absPath of file >>> MarkdownRemark\",\"html\":\"<p>I’ve been pretty heads down in a <a href=\\\"http://www.thoughtworks.com\\\">ThoughtWorks</a> project for the better\\npart of 2013 and have unfortunately neglected this blog. But 2014 is a new year and I want to get\\ninto a semi-regular cadence of posts.</p>\\n<p>So with that in mind…… another long overdue post! So say hello to\\n<a href=\\\"https://github.com/ryanoglesby08/lazy-doc\\\">LazyDoc</a>, a Ruby gem I have released. LazyDoc provides a\\nDSL for extracting deeply nested values from a JSON document.</p>\\n<h2>Working with APIs</h2>\\n<p>In many projects I work on these days, the application consumes a 3rd party or internal API. In\\nRuby, it’s tempting to just parse a JSON response from an API into a Hash and then pass that around\\nyour application.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-ruby\\\"><code class=\\\"language-ruby\\\"><span class=\\\"token keyword\\\">def</span> <span class=\\\"token function\\\">extract_user_from</span><span class=\\\"token punctuation\\\">(</span>json_body<span class=\\\"token punctuation\\\">)</span>\\n  <span class=\\\"token constant\\\">JSON</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">parse</span><span class=\\\"token punctuation\\\">(</span>json_body<span class=\\\"token punctuation\\\">)</span>\\n<span class=\\\"token keyword\\\">end</span></code></pre>\\n      </div>\\n<p>This “works”, but now your application is tightly coupled to the structure of the API response. The\\nfields your application needs are never defined, making it tough to know what you have available to\\nuse. Is the “name” field “first_name”, “firstName”, or just “name”?</p>\\n<p>Ok, easy enough solution for that. Objects to the rescue!</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-ruby\\\"><code class=\\\"language-ruby\\\"><span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">User</span>\\n  attr_reader <span class=\\\"token symbol\\\">:first_name</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token symbol\\\">:last_name</span>\\n\\n  <span class=\\\"token keyword\\\">def</span> <span class=\\\"token function\\\">initialize</span><span class=\\\"token punctuation\\\">(</span>first_name<span class=\\\"token punctuation\\\">,</span> last_name<span class=\\\"token punctuation\\\">)</span>\\n    <span class=\\\"token variable\\\">@first_name</span> <span class=\\\"token operator\\\">=</span> first_name\\n    <span class=\\\"token variable\\\">@last_name</span> <span class=\\\"token operator\\\">=</span> last_name\\n  <span class=\\\"token keyword\\\">end</span>\\n<span class=\\\"token keyword\\\">end</span>\\n\\n<span class=\\\"token punctuation\\\">.</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token punctuation\\\">.</span>\\n\\n<span class=\\\"token keyword\\\">def</span> <span class=\\\"token function\\\">extract_user_from</span><span class=\\\"token punctuation\\\">(</span>json_body<span class=\\\"token punctuation\\\">)</span>\\n  body <span class=\\\"token operator\\\">=</span> <span class=\\\"token constant\\\">JSON</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">parse</span><span class=\\\"token punctuation\\\">(</span>json_body<span class=\\\"token punctuation\\\">)</span>\\n  <span class=\\\"token constant\\\">User</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token keyword\\\">new</span><span class=\\\"token punctuation\\\">(</span>body<span class=\\\"token punctuation\\\">[</span><span class=\\\"token string\\\">'first_name'</span><span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">,</span> body<span class=\\\"token punctuation\\\">[</span><span class=\\\"token string\\\">'last_name'</span><span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">)</span>\\n<span class=\\\"token keyword\\\">end</span></code></pre>\\n      </div>\\n<p>Now we have separated the JSON response from our application domain. Sweet! Ok, done… Right? Not\\nquite. There are a few problems here.</p>\\n<ol>\\n<li>What about everything else in <code class=\\\"language-text\\\">json_body</code>? It is now lost. :(</li>\\n<li>What do you do when you need to extract more information from that JSON response? This code isn’t\\nvery flexible. Either you end up with a constructor that takes in too many arguments, or you end\\nup with too many setters on your <code class=\\\"language-text\\\">User</code> object.</li>\\n<li>Many times you want to massage your API response data a little bit before adding it to your\\nobject. These massaging operations end up going into random helper methods that end up being\\nduplicated all over your codebase.</li>\\n</ol>\\n<p>We can do better.</p>\\n<h2>Embedded Document Pattern</h2>\\n<p>The <strong>Embedded Document Pattern</strong> to the rescue! Defined by Martin Fowler\\n<a href=\\\"http://martinfowler.com/bliki/EmbeddedDocument.html\\\">here</a>. With this pattern, instead of parsing\\nthrough your documents when they are received and building object graphs, we cache the document and\\nonly parse through it when necessary. Because sometimes your document may be large compared to the\\nnumber of properties your application actually needs, you can save complexity and time.</p>\\n<p>The LazyDoc gem is a Ruby implementation of the Embedded Document Pattern. You maintain access to\\nthe entire JSON response, which makes it easy to add, update, or remove fields from your object as\\nyou need. You retain flexibility. Any massaging that needs to be done to the fields becomes easy to\\nmanage.</p>\\n<p>So now, with LazyDoc:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-ruby\\\"><code class=\\\"language-ruby\\\"><span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">User</span>\\n  include <span class=\\\"token constant\\\">LazyDoc</span><span class=\\\"token punctuation\\\">:</span><span class=\\\"token punctuation\\\">:</span><span class=\\\"token constant\\\">DSL</span>\\n\\n  access <span class=\\\"token symbol\\\">:first_name</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token symbol\\\">:last_name</span>\\n  access <span class=\\\"token symbol\\\">:address</span><span class=\\\"token punctuation\\\">,</span> default<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">'NONE PROVIDED'</span>\\n\\n  <span class=\\\"token keyword\\\">def</span> <span class=\\\"token function\\\">initialize</span><span class=\\\"token punctuation\\\">(</span>document<span class=\\\"token punctuation\\\">)</span>\\n    <span class=\\\"token function\\\">lazily_parse</span><span class=\\\"token punctuation\\\">(</span>document<span class=\\\"token punctuation\\\">)</span>\\n  <span class=\\\"token keyword\\\">end</span>\\n<span class=\\\"token keyword\\\">end</span>\\n\\n<span class=\\\"token punctuation\\\">.</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token punctuation\\\">.</span>\\n\\n<span class=\\\"token keyword\\\">def</span> <span class=\\\"token function\\\">extract_user_from</span><span class=\\\"token punctuation\\\">(</span>json_body<span class=\\\"token punctuation\\\">)</span>\\n  <span class=\\\"token constant\\\">User</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token keyword\\\">new</span><span class=\\\"token punctuation\\\">(</span>json_body<span class=\\\"token punctuation\\\">)</span>\\n<span class=\\\"token keyword\\\">end</span></code></pre>\\n      </div>\\n<h2>Lazy?</h2>\\n<p>So why is it called <em>Lazy</em>Doc? The lazy feature is one of the coolest parts of this gem. The\\ndeclarative method <code class=\\\"language-text\\\">access :first_name</code> merely defines a method that is able to fetch the\\n<code class=\\\"language-text\\\">first_name</code> property from the JSON body. Only upon calling the method will the property be\\nextracted and massaged according to any defined operations. Additionally, the returned value will be\\ncached, so any subsequent calls will only return the cached value.</p>\\n<p>Check the <a href=\\\"https://github.com/ryanoglesby08/lazy-doc\\\">README</a> for more information and examples.\\nAlso, the <a href=\\\"https://github.com/ryanoglesby08/lazy-doc/tree/v0.4.0/spec/acceptance\\\">acceptance specs</a>\\nhave full example usage.</p>\\n<p>Feel free to download and use in your next project! Feedback is welcome!</p>\",\"frontmatter\":{\"title\":\"Meet LazyDoc\",\"date\":\"December 25, 2013\"}}},\"pathContext\":{\"slug\":\"/meet-lazydoc/\",\"previous\":{\"fields\":{\"slug\":\"/fun-with-rails-i18n/\"},\"frontmatter\":{\"title\":\"Fun With Rails I18n\"}},\"next\":{\"fields\":{\"slug\":\"/goto-chicago-2014-experience-report/\"},\"frontmatter\":{\"title\":\"GOTO Chicago 2014 Experience Report\"}}}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/meet-lazydoc.json\n// module id = 500\n// module chunks = 74163788938612"],"sourceRoot":""}